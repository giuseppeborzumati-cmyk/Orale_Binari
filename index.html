<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Verifiche Informatica - Borzumati</title>
    <!-- Carica Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .code-font { font-family: 'Roboto Mono', monospace; }
        .code-block { background-color: #1e293b; color: #f8fafc; padding: 0.75rem; border-radius: 0.5rem; overflow-x: auto; }

        /* Stili per la stampa PDF (ottimizzazione 2 pagine A4) */
        @media print {
            body { font-family: sans-serif !important; font-size: 10pt; background: white !important; }
            /* Nasconde tutto tranne l'area di stampa */
            body > *:not(.print-container) { display: none !important; }
            .print-container { 
                display: block !important; 
                max-width: none !important; 
                margin: 0 !important; 
                padding: 1.5cm 1cm !important; /* Margini A4 */
                box-shadow: none !important; 
                height: auto;
                min-height: 29.7cm; /* Altezza A4 per simulazione */
            }
            @page { margin: 1cm; size: a4 portrait; }
            
            .print-header { border-bottom: 2px solid #6366f1; padding-bottom: 0.5rem; margin-bottom: 1rem; }
            .print-header h1 { font-size: 14pt !important; font-weight: bold; }
            .print-header p { font-size: 9pt !important; color: #374151; }
            
            .question-item { 
                margin-bottom: 1.5rem; 
                page-break-inside: avoid;
                border-left: 4px solid #6366f1;
                padding-left: 0.75rem;
                counter-increment: question-counter;
                font-size: 11pt;
            }
            .question-item::before {
                content: counter(question-counter) ". ";
                font-weight: bold;
                margin-right: 0.25rem;
                color: #6366f1;
            }
            .question-text { font-weight: 600; color: #1f2937; margin-bottom: 0.4rem; line-height: 1.4; }
            .question-text strong { font-weight: 700; color: #1f2937; }

            .answer-line { 
                min-height: 1.5em; 
                display: block; 
                border-bottom: 1px dashed #9ca3af; 
                width: 100%; 
                margin-top: 0.5rem; 
            }
            .solution-box { 
                border: 1px solid #10b981; 
                background-color: #d1fae5; 
                color: #065f46;
                padding: 0.3rem 0.6rem; 
                border-radius: 4px; 
                margin-top: 0.6rem; 
                font-size: 9pt;
                font-family: 'Roboto Mono', monospace;
                white-space: pre-wrap;
            }
            /* Aggiunge spazio extra dopo l'ultima domanda */
            .print-footer { padding-top: 3cm; text-align: center; font-size: 8pt; color: #6b7280; }
        }

        /* Stili per i pulsanti animati */
        .action-button { transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); font-weight: 700; position: relative; overflow: hidden; }
        .action-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); }
        .action-button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.2); transform: skewX(-20deg); transition: all 0.7s; }
        .action-button:hover::before { left: 100%; }
        .bg-gradient-blue { background-image: linear-gradient(to right, #4c66ff 0%, #00c6ff 100%); }
        .bg-gradient-green { background-image: linear-gradient(to right, #10b981 0%, #1d7c4c 100%); }
    </style>
</head>
<body class="bg-gray-900 min-h-screen p-4 sm:p-8">

    <!-- Area di caricamento -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="text-center text-white">
            <svg class="animate-spin h-10 w-10 text-indigo-400 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-lg font-semibold">Caricamento dati in corso... (Connessione a Firebase)</p>
        </div>
    </div>
    
    <!-- Sezione Dati Studente/Docente e Introduzione -->
    <div id="main-view" class="w-full max-w-7xl mx-auto bg-white rounded-xl shadow-[0_25px_50px_-12px_rgba(0,0,0,0.5)] p-6 sm:p-12 mb-8 space-y-10">
        <header class="text-center pb-6 border-b-4 border-indigo-500">
            <h1 class="text-4xl sm:text-6xl font-black leading-tight">
                <span class="bg-clip-text text-transparent bg-gradient-to-r from-blue-700 to-purple-600"> GENERATORE VERIFICHE INFORMATICA </span>
            </h1>
            <p class="text-xl text-gray-700 mt-2">Prof. Giuseppe Borzumati | 11 Domande Miste Pratica + Teoria Complessa</p>
        </header>

        <!-- Dati Studente per la Generazione (Globali) -->
        <div class="bg-indigo-50 p-8 rounded-2xl shadow-inner border border-indigo-200">
            <h2 class="text-2xl font-bold text-indigo-800 mb-5 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-7 h-7 mr-2 text-indigo-600">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z" />
                </svg> 
                Dati Base
                <span id="teacher-id" class="code-font text-xs ml-4 p-1 bg-indigo-200 text-indigo-800 rounded"></span>
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div> <input type="text" id="nome-studente" placeholder="Nome" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="text" id="cognome-studente" placeholder="Cognome" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="text" id="classe-studente" placeholder="Classe (es. 4B)" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="date" id="data-verifica" value="" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
            </div>
            <p class="text-sm text-indigo-600 mt-4 font-semibold">Tutti i campi sono obbligatori per generare il link di correzione.</p>
        </div>

        <!-- Contenitore delle Verifiche (4 Blocchi) -->
        <div class="space-y-12">

            <!-- BLOCCO 1: Verifiche Numeriche PURE -->
            <div id="blocco-verifica-a" class="p-8 bg-red-50 border-t-8 border-t-red-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-red-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üî¢</span> VERIFICA A: Sistemi di Numerazione Base & Operazioni
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Conversione Base (2, 8, 10, 16), Frazioni Binarie, Numeri Romani, Divisione Binaria e Operazioni. (11 Domande Miste)</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('A', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('A', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-A" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-red-600 border-b border-red-300 pb-1">Link di Correzione Generati (Verifica A):</h4>
                    <p class="text-sm text-gray-500" id="link-message-A">Nessuna verifica di Tipo A generata.</p>
                </div>
            </div>

            <!-- BLOCCO 2: A + Networking Semplice -->
            <div id="blocco-verifica-b" class="p-8 bg-purple-50 border-t-8 border-t-purple-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-purple-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üåê</span> VERIFICA B: Sistemi di Numerazione + Networking Semplice
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Contenuti della Verifica A + Subnetting Semplice (CIDR, Network/Broadcast ID, Maschera). (11 Domande Miste)</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('B', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('B', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-B" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-purple-600 border-b border-purple-300 pb-1">Link di Correzione Generati (Verifica B):</h4>
                    <p class="text-sm text-gray-500" id="link-message-B">Nessuna verifica di Tipo B generata.</p>
                </div>
            </div>

            <!-- BLOCCO 3: A + Networking Semplice (uguale a B per bilanciamento) -->
            <div id="blocco-verifica-c" class="p-8 bg-teal-50 border-t-8 border-t-teal-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-teal-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üî¨</span> VERIFICA C: Sistemi di Numerazione + Networking Semplice
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Contenuti della Verifica A + Subnetting Semplice (CIDR, Network/Broadcast ID, Maschera). (11 Domande Miste) - Ideale per un'alternativa alla B.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('C', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('C', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-C" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-teal-600 border-b border-teal-300 pb-1">Link di Correzione Generati (Verifica C):</h4>
                    <p class="text-sm text-gray-500" id="link-message-C">Nessuna verifica di Tipo C generata.</p>
                </div>
            </div>
            
            <!-- BLOCCO 4: Riepilogo Completo e Problemi Critici (Verifica D) -->
            <div id="blocco-verifica-d" class="p-8 bg-yellow-50 border-t-8 border-t-yellow-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-yellow-800 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">‚≠ê</span> VERIFICA D: Riepilogo Completo (Complemento a 2, Floating Point, IP Avanzato)
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Mix di tutti gli argomenti avanzati: Complemento a Due, Floating Point e Subnetting complesso (**VLSM**). (11 Domande Miste)</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('D', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('D', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-D" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-yellow-600 border-b border-yellow-300 pb-1">Link di Correzione Generati (Verifica D):</h4>
                    <p class="text-sm text-gray-500" id="link-message-D">Nessuna verifica di Tipo D generata.</p>
                </div>
            </div>

        </div>

        <footer class="text-center pt-8 text-gray-500 text-sm border-t border-gray-200">
            <p>Sistema di Generazione Verifiche v5.2 | Per l'Insegnante Giuseppe Borzumati. Assicurati che il pop-up del browser sia consentito per scaricare il PDF.</p>
        </footer>
    </div>

    <!-- VISTA DI CORREZIONE (Caricata tramite link condivisibile) -->
    <div id="correction-view" class="hidden w-full max-w-5xl mx-auto bg-white rounded-xl shadow-2xl p-6 sm:p-10 mb-8 space-y-8">
        <header class="text-center pb-4 border-b-4 border-green-500">
            <h1 class="text-4xl font-extrabold text-green-700 leading-tight">Griglia di Correzione Interattiva</h1>
            <p class="text-lg text-gray-600 mt-1">
                Studente: <span id="corr-student-name" class="font-extrabold text-indigo-600"></span> - 
                Classe: <span id="corr-class" class="font-extrabold text-indigo-600"></span> - 
                Verifica <span id="corr-title" class="font-bold"></span>
            </p>
        </header>

        <!-- Tabella Punteggio e Voto -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 bg-yellow-50 p-6 rounded-xl border-2 border-yellow-300 shadow-lg">
            <div class="col-span-1 lg:col-span-3">
                <h2 class="text-2xl font-bold text-yellow-800 mb-2 border-b border-yellow-400 pb-1">Valutazione</h2>
            </div>
            
            <div class="bg-blue-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-blue-800">Punti Ottenuti (Scritto):</p>
                <p class="text-4xl font-extrabold text-blue-600 mt-1"><span id="corr-points">0</span> / <span id="corr-max-points">11</span></p>
            </div>
            
            <div class="bg-purple-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-purple-800">Voto Orale (Peso 30%):</p>
                <input type="number" id="voto-orale" min="0" max="10" step="0.1" value="6.0" onchange="updateFinalGrade()" class="p-2 border-2 border-purple-500 rounded-lg w-full mt-1 text-xl font-bold">
            </div>
            
            <div class="bg-red-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-red-800">Voto Finale (Arrotondato per Difetto):</p>
                <p class="text-4xl font-extrabold text-red-600 mt-1"><span id="corr-grade-floored">0</span> / 10</p>
            </div>
            
            <div class="col-span-1 lg:col-span-3 bg-gray-100 p-4 rounded-lg border border-gray-300" id="conversion-explanation">
                <p class="text-sm font-bold text-gray-700">Formula di Calcolo:</p>
                <code class="code-font text-xs block mt-1 p-2 bg-white rounded"> Voto Scritto Base 10 = (Punti Ottenuti / 11) * 10 = <span id="voto-scritto-base">0.00</span> </code>
                <code class="code-font text-xs block mt-1 p-2 bg-white rounded"> Voto Finale = (Voto Scritto Base 10 * 0.7) + (Voto Orale * 0.3) </code>
            </div>
        </div>

        <!-- Esercizi con Correzione -->
        <div id="correction-form" class="space-y-6"> 
            <!-- Gli esercizi e i campi di input saranno popolati qui dal JS -->
        </div>

        <button class="action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-lg mt-8 w-full" onclick="saveAndDownloadResultsPDF()"> Salva Risultati e Scarica PDF dei Commenti </button>
        <button class="action-button bg-gray-400 hover:bg-gray-500 text-gray-900 py-3 px-6 rounded-lg text-lg w-full" onclick="window.location.href = window.location.origin + window.location.pathname"> Torna alla Generazione Verifiche </button>
    </div>

    <!-- Contenitore Nascosto per la Stampa PDF (Stile ottimizzato per PDF) -->
    <div id="print-area" class="print-container hidden"></div>

    <!-- Firebase SDK Imports (mantenuto come nel prototipo) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, query, where, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Imposta il livello di log per debug
        setLogLevel('Debug');

        // Variabili Globali del Modulo
        window.db = null;
        window.auth = null;
        window.teacherId = null;
        window.MAX_POINTS = 11; // Punti massimi per la verifica (1 punto per domanda)

        // Configurazione Firebase: Usa le variabili globali
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        
        // Variabile ID App (usata per il path Firestore)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Funzione di Inizializzazione Firebase
        async function initializeFirebase() {
            window.showLoading();
            try {
                // 1. Inizializzazione App
                const app = initializeApp(firebaseConfig);
                window.db = getFirestore(app);
                window.auth = getAuth(app);

                // 2. Autenticazione Anonima o con Token
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(window.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }
                
                window.teacherId = window.auth.currentUser.uid;
                
                // 3. Nascondi Overlay e Avvia l'app
                document.getElementById('teacher-id').textContent = `Docente ID: ${window.teacherId.substring(0, 8)}...`;

                // 4. Carica i link di correzione esistenti
                await window.updateLinkContainers();

                // 5. Verifica se √® una vista di correzione
                const urlParams = new URLSearchParams(window.location.search);
                const examId = urlParams.get('examId');
                if (examId) {
                    await window.loadCorrectionView(examId);
                } else {
                    window.showMainView();
                }

            } catch (error) {
                console.error("Errore fatale nell'inizializzazione di Firebase e Auth:", error);
                const errorMsg = "Errore di connessione al database. Controlla la console. (ID App: " + appId + ")";
                document.getElementById('loading-overlay').innerHTML = `<p class="text-red-400 text-xl font-bold">${errorMsg}</p>`;
                window.hideLoading();
            }
        }

        // Metodo per ottenere il path corretto per Firestore (pubblico)
        window.getExamCollectionRef = () => {
             return collection(window.db, "artifacts", appId, "public", "data", "exams");
        };

        // ESPORTA LE FUNZIONI DI FIRESTORE NEL CONTESTO GLOBALE
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.getDocs = getDocs;

        // Esegui l'inizializzazione al caricamento
        window.addEventListener('load', () => {
            initializeFirebase();
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('data-verifica').value = today;
            document.getElementById('corr-max-points').textContent = window.MAX_POINTS;
        });
    </script>
    
    <script>
        // -------------------------------------------------------------------------
        // LOGICA DI VISTA E UTILITY
        // -------------------------------------------------------------------------

        let currentExamData = null; // Dati della verifica attualmente in correzione
        
        window.showLoading = () => document.getElementById('loading-overlay').classList.remove('hidden');
        window.hideLoading = () => document.getElementById('loading-overlay').classList.add('hidden');

        // Navigazione tra le viste
        window.showMainView = () => {
            document.getElementById('main-view').classList.remove('hidden');
            document.getElementById('correction-view').classList.add('hidden');
            window.hideLoading();
        };
        window.showCorrectionView = () => {
            document.getElementById('main-view').classList.add('hidden');
            document.getElementById('correction-view').classList.remove('hidden');
            window.hideLoading();
        };

        // Funzione per generare un ID unico
        const generateUniqueID = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 5);

        // Funzione per pulire e standardizzare le risposte (tolleranza)
        const cleanAnswer = (s) => s.toString()
            .trim()
            .toUpperCase()
            .replace(/[^A-Z0-9\.\/\;\-\+\s]/g, '') // Rimuove caratteri non validi
            .replace(/\s+/g, ''); // Rimuove tutti gli spazi

        // Funzione per formattare una risposta per la soluzione
        const formatSolution = (s) => s.toString().replace(/\n/g, '<br>');


        // -------------------------------------------------------------------------
        // FUNZIONI NUMERICHE DI CALCOLO (CRITICHE)
        // -------------------------------------------------------------------------

        // Genera un numero intero casuale in un range (incluso)
        const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        // Conversione Decimale a Romano (fino a 999)
        function decToRoman(num) {
            const map = { 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' };
            let roman = '';
            for (let i of Object.keys(map).map(Number).sort((a, b) => b - a)) {
                while (num >= i) {
                    roman += map[i];
                    num -= i;
                }
            }
            return roman;
        }

        // Funzione per calcolare il Complemento a Due (8 bit)
        function toTwosComplement(num) {
            if (num > 127 || num < -128) return 'OVERFLOW';
            if (num >= 0) {
                return num.toString(2).padStart(8, '0');
            }
            
            const absNum = Math.abs(num);
            let bin = absNum.toString(2).padStart(8, '0');
            
            // 1. Inverti i bit
            let inverted = [...bin].map(b => b === '0' ? '1' : '0').join('');
            
            // 2. Aggiungi 1 (in binario)
            let carry = 1;
            let twosComp = '';
            for (let i = 7; i >= 0; i--) {
                let bit = parseInt(inverted[i], 10);
                let sum = bit + carry;
                twosComp = (sum % 2) + twosComp;
                carry = Math.floor(sum / 2);
            }
            return twosComp;
        }
        
        // Calcolo Notazione Scientifica Binaria (Floating Point Semplificato: Mantissa 10 bit, Esponente non-biased)
        function calculateFloatingPoint(dec) {
            let num = Math.abs(dec);
            if (num === 0) return { E: 0, mantissa: '0'.repeat(10), binary_norm: '0' };
            
            let binary = num.toString(2);
            let dotIndex = binary.indexOf('.');
            
            if (dotIndex === -1) {
                dotIndex = binary.length;
                binary += '.0';
            }

            let normalized = binary.replace('.', '');
            let E = 0;

            // Calcola l'esponente E
            if (num >= 1) {
                E = dotIndex - 1;
            } else {
                let firstOneIndexAfterDot = binary.split('.')[1].indexOf('1');
                E = -(firstOneIndexAfterDot + 1);
            }
            
            // Normalizza e ottieni la Mantissa (parte frazionaria dopo l'1 implicito)
            const binaryWithOneDot = num.toString(2).split('.');
            let integerPart = binaryWithOneDot[0];
            let fractionalPart = binaryWithOneDot.length > 1 ? binaryWithOneDot[1] : '';

            let mantissaSource;
            if (num >= 1) {
                mantissaSource = integerPart.substring(1) + fractionalPart;
            } else {
                let temp = binary.split('.');
                let frac = temp.length > 1 ? temp[1] : '';
                let firstOne = frac.indexOf('1');
                mantissaSource = frac.substring(firstOne + 1);
            }
            
            const mantissa = mantissaSource.padEnd(10, '0').substring(0, 10);
            
            return {
                E: E, // Esponente non-biased
                mantissa: mantissa, // 10-bit fractional part
                binary_norm: `1.${mantissa} x 2^${E}`
            };
        }

        // Divisione Binaria (su interi)
        function binaryDivision(dividendDec, divisorDec) {
            const quotientDec = Math.floor(dividendDec / divisorDec);
            const remainderDec = dividendDec % divisorDec;

            const dividendBin = dividendDec.toString(2);
            const divisorBin = divisorDec.toString(2);
            const quotientBin = quotientDec.toString(2);
            const remainderBin = remainderDec.toString(2);

            return {
                quotientBin,
                remainderBin
            };
        }

        // Funzione per calcolare ID Rete/Broadcast (per subnetting semplice e avanzato)
        function calculateNetworkIDs(ip, mask) {
            const octets = ip.split('.').map(o => parseInt(o));
            const ipBin = octets.map(o => o.toString(2).padStart(8, '0')).join('');
            
            const networkPart = ipBin.substring(0, mask);
            
            // Network ID (host part = 0)
            const netIDBinary = networkPart.padEnd(32, '0');
            let networkID = [];
            for (let n = 0; n < 4; n++) {
                networkID.push(parseInt(netIDBinary.substring(n * 8, n * 8 + 8), 2));
            }
            const netID = networkID.join('.');

            // Broadcast ID (host part = 1)
            const hostPart = '1'.repeat(32 - mask);
            const broadcastBinary = networkPart + hostPart;
            let broadcastID = [];
            for (let n = 0; n < 4; n++) {
                broadcastID.push(parseInt(broadcastBinary.substring(n * 8, n * 8 + 8), 2));
            }
            const bcastID = broadcastID.join('.');
            
            // Maschera decimale
            const maskBin = '1'.repeat(mask).padEnd(32, '0');
            let maskDec = [];
            for (let n = 0; n < 4; n++) {
                maskDec.push(parseInt(maskBin.substring(n * 8, n * 8 + 8), 2));
            }
            const subnetMask = maskDec.join('.');

            return { network: netID, broadcast: bcastID, mask: subnetMask };
        }

        // -------------------------------------------------------------------------
        // POOL DI GENERATORI DI DOMANDE MISTE (11)
        // -------------------------------------------------------------------------

        function generateMixedQuestion(qNum, examType) {
            let question = { text: '', correct: '', type: '' };
            let num1, num2, ip, mask, result, bin1, bin2, op, netRes;
            
            // La generazione dipende dal numero di domanda e dal tipo di verifica
            switch (qNum) {
                // Q1: Decimale -> Binario (Intero) + Teoria Semplice
                case 1:
                    num1 = randInt(150, 511);
                    result = num1.toString(2);
                    question.type = 'Conversione (10->2) + Teoria Base';
                    question.text = `**PARTE PRATICA:** Converti il numero Decimale **${num1}** in **Binario** (base 2).
                        **PARTE TEORICA:** Qual √® la base del sistema numerico Ottale? Come si chiama il metodo di conversione utilizzato per convertire numeri da Base 10 a Base N?`;
                    question.correct = `${result}; Base 8; Divisioni successive`;
                    break;
                
                // Q2: Esadecimale/Binario -> Base 10 + Teoria Complessa
                case 2:
                    if (examType === 'D') {
                        // Advanced: Hex -> Binario (grande)
                        num1 = randInt(4096, 65535); // 16 bit
                        const hexInput = num1.toString(16).toUpperCase();
                        result = num1.toString(2).padStart(16, '0');
                        question.type = 'Conversione (16->2) + Teoria Complessa';
                        question.text = `**PARTE PRATICA:** Converti il numero Esadecimale **${hexInput}** in **Binario** (16 bit).
                            **PARTE TEORICA:** Spiega l'utilit√† del sistema Esadecimale (base 16) nella rappresentazione degli indirizzi di memoria (es. in architettura x64). Perch√© viene preferito rispetto al Binario in questo contesto?`;
                        question.correct = result;
                    } else {
                        // Standard: Hex -> Decimal
                        num1 = randInt(256, 1024);
                        const hexInput = num1.toString(16).toUpperCase();
                        result = num1.toString();
                        question.type = 'Conversione (16->10) + Teoria Complessa';
                        question.text = `**PARTE PRATICA:** Converti il numero Esadecimale **${hexInput}** in **Decimale** (base 10).
                            **PARTE TEORICA:** Spiega in modo dettagliato come la grandezza del numero di bit utilizzati influenzi la **risoluzione** (precisione) e l'**intervallo** (range) dei valori rappresentabili.`;
                        question.correct = result;
                    }
                    break;

                // Q3: Frazione Binaria -> Decimale + Teoria (Errore)
                case 3:
                    const intPart = randInt(1, 15);
                    const fracBin = (Math.random() * 0.999).toString(2).substring(2, 7); // 5 bit frazionari
                    const binInput = `${intPart.toString(2)}.${fracBin}`;
                    
                    let decimalValue = intPart;
                    for(let i=0; i < fracBin.length; i++) {
                        decimalValue += parseInt(fracBin[i]) * Math.pow(2, -(i+1));
                    }
                    result = decimalValue.toFixed(4);
                    
                    question.type = 'Frazione (2->10) + Errore di Rappresentazione';
                    question.text = `**PARTE PRATICA:** Dato il numero Binario con la virgola **${binInput}**, calcola il suo equivalente in Base **DECIMALE** (risultato con 4 cifre decimali, separatore punto).
                        **PARTE TEORICA:** Descrivi il concetto di **errore di rappresentazione** nelle frazioni binarie. Fai un esempio di un numero decimale comune (es. 0.1 o 0.2) che causa questo errore quando convertito in binario.`;
                    question.correct = result;
                    break;
                
                // Q4: Divisione Binaria (MANDATORIA)
                case 4:
                    num1 = randInt(30, 60); // Dividendo
                    num2 = randInt(4, 10); // Divisore
                    const division = binaryDivision(num1, num2);
                    
                    question.type = 'Divisione Binaria (Q+R)';
                    question.text = `**PARTE PRATICA:** Esegui la divisione tra **${num1.toString(2)}** / **${num2.toString(2)}**. Fornisci il **Quoziente** e il **Resto** in **Binario**.
                        **PARTE TEORICA:** Spiega in breve il meccanismo di **Sottrazione Ripetuta** in Binario per eseguire questa operazione.`;
                    question.correct = `Quoziente: ${division.quotientBin}; Resto: ${division.remainderBin}`;
                    break;
                
                // Q5: Operazione Binaria (+/-) o Complemento a Due
                case 5:
                    if (examType === 'D') {
                        // Advanced: Complemento a Due (Sottrazione con somma)
                        num1 = randInt(50, 100);
                        num2 = randInt(20, 40);
                        const num2_neg_comp = toTwosComplement(-num2);
                        const expected_dec = num1 - num2;
                        
                        question.type = 'Complemento a Due (Sottrazione)';
                        question.text = `**PARTE PRATICA:** Esegui l'operazione di sottrazione **${num1} - ${num2}** utilizzando il Complemento a Due su **8 bit**. Fornisci il Binario del risultato (dopo la somma).
                            **PARTE TEORICA:** Spiega il ruolo del bit pi√π significativo (MSB) nel Complemento a Due e descrivi il concetto di **Overflow** in questo contesto.`;
                        question.correct = toTwosComplement(expected_dec);
                    } else {
                        // Standard: Addizione Binaria
                        num1 = randInt(50, 100);
                        num2 = randInt(10, 40);
                        bin1 = num1.toString(2);
                        bin2 = num2.toString(2);
                        result = (num1 + num2).toString(2);
                        
                        question.type = 'Addizione Binaria (+/-) con Riporto';
                        question.text = `**PARTE PRATICA:** Esegui la somma binaria: **${bin1} + ${bin2}**. Fornisci il risultato binario.
                            **PARTE TEORICA:** Spiega perch√© la circuiteria digitale (ALU) usa solo l'addizione per eseguire sia l'addizione che la sottrazione (tramite C2).`;
                        question.correct = result;
                    }
                    break;
                
                // Q6: Conversione Decimale -> Romani/Ottale + Teoria (Posizionale)
                case 6:
                    if (examType === 'D') {
                        // Advanced: Decimale -> Ottale
                        num1 = randInt(500, 1024);
                        result = num1.toString(8);
                        question.type = 'Conversione (10->8) + Teoria Posizionale';
                        question.text = `**PARTE PRATICA:** Converti il numero Decimale **${num1}** nel suo equivalente in **Ottale** (base 8).
                            **PARTE TEORICA:** Descrivi il principio del sistema di numerazione **posizionale** (come 10, 2, 8, 16) e spiega in che modo differisce dai sistemi non posizionali (come i Romani).`;
                        question.correct = result;
                    } else {
                        // Standard: Decimale -> Romani
                        num1 = randInt(100, 999);
                        result = decToRoman(num1);
                        question.type = 'Romani (10->R) + Teoria';
                        question.text = `**PARTE PRATICA:** Converti il numero Decimale **${num1}** nel suo equivalente in **Numeri Romani**.
                            **PARTE TEORICA:** Spiega in breve l'impossibilit√† di rappresentare lo **Zero** e i numeri **Negativi** nei Numeri Romani e perch√© questo √® un grosso limite per i calcolatori.`;
                        question.correct = result;
                    }
                    break;

                // Q7: Conversione Binario -> Ottale/Esadecimale
                case 7:
                    num1 = randInt(4000, 8000);
                    bin1 = num1.toString(2).padStart(13, '0'); // 13 bit
                    const octalRes = parseInt(bin1, 2).toString(8);
                    const hexRes = parseInt(bin1, 2).toString(16).toUpperCase();
                    
                    question.type = 'Conversione (2->8/16)';
                    question.text = `**PARTE PRATICA:** Dato il numero binario **${bin1}**, convertilo nel suo equivalente in **Ottale** (base 8) e in **Esadecimale** (base 16).
                        **PARTE TEORICA:** Spiega il metodo rapido per convertire dal Binario all'Ottale e all'Esadecimale (raggruppamento), giustificandone il motivo matematico.`;
                    question.correct = `Ottale: ${octalRes}; Esadecimale: ${hexRes}`;
                    break;
                
                // Q8: Networking/IP Semplice (presente in tutti)
                case 8:
                    if (examType === 'A') {
                         question.type = 'Networking (Teoria Base)';
                         question.text = `**PARTE PRATICA:** Non richiesta.
                            **PARTE TEORICA:** Descrivi brevemente i tre tipi di indirizzi IP (A, B, C) e le loro classi predefinite (CIDR), evidenziando la loro principale differenza in termini di dimensione della rete e numero massimo di host.`;
                         question.correct = 'Teoria da valutare in base al contenuto (Classi A, B, C, CIDR /8, /16, /24, max host)';
                    } else {
                        // B, C, D: IP Class B/C con CIDR per calcolo Network ID
                        ip = `192.168.${randInt(1, 254)}.${randInt(1, 254)}`;
                        mask = randInt(25, 30);
                        netRes = calculateNetworkIDs(ip, mask);

                        question.type = 'Subnetting Semplice (Net ID)';
                        question.text = `**PARTE PRATICA:** Data la coppia IP/CIDR **${ip}/${mask}**, calcola il **Network ID** e la **Subnet Mask** in decimale.
                            **PARTE TEORICA:** Spiega il concetto di **subnetting** e perch√© √® necessario per la gestione efficiente dello spazio di indirizzamento IP.`;
                        question.correct = `Network ID: ${netRes.network}; Subnet Mask: ${netRes.mask}`;
                    }
                    break;

                // Q9: Conversione Ottale -> Decimale + Teoria (Struttura Bit)
                case 9:
                    num1 = randInt(100, 250); // Numero Ottale
                    result = parseInt(num1.toString(), 8).toString();
                    
                    question.type = 'Conversione (8->10) + Teoria Bit';
                    question.text = `**PARTE PRATICA:** Converti il numero Ottale **${num1}** in **Decimale** (base 10).
                        **PARTE TEORICA:** Spiega la differenza tra la rappresentazione in memoria di un **carattere** (es. 'A' in ASCII o Unicode) e un **numero intero** (es. 65) in termini di bit utilizzati e interpretazione.`;
                    question.correct = result;
                    break;
                
                // Q10: Networking Avanzato (VLSM) o Teoria Semplice
                case 10:
                    if (examType === 'D') {
                        // Advanced: VLSM (Subnetting Variabile)
                        const vlsm = generateVLSMQuestion();
                        question.type = 'Subnetting Avanzato (VLSM)';
                        question.text = `**PARTE PRATICA:** Hai la rete **${vlsm.baseIP}**. Devi creare due sottoreti: la Subnet A richiede **${vlsm.hostsA} host** e la Subnet B ne richiede **${vlsm.hostsB} host**.
                            Partendo dalla Subnet A (la pi√π grande), determina il suo **CIDR** e il suo **Broadcast ID**.
                            **PARTE TEORICA:** Spiega in cosa consiste il **VLSM** (Variable Length Subnet Masking) e perch√© √® pi√π efficiente del subnetting tradizionale (FLSM).`;
                        question.correct = `CIDR A: /${vlsm.maskA}; Broadcast ID A: ${vlsm.bcastID_A}; Prossima Rete: ${vlsm.nextNetID}/${vlsm.maskB}`;
                    } else {
                        // Standard: Base Decimale -> Ottale
                        num1 = randInt(200, 500);
                        result = num1.toString(8);
                        question.type = 'Conversione (10->8) + Teoria Bit';
                        question.text = `**PARTE PRATICA:** Converti il numero Decimale **${num1}** nel suo equivalente in **Ottale** (base 8).
                            **PARTE TEORICA:** Perch√© √® importante che le basi numeriche utilizzate siano potenze di 2 (come 2, 8, 16) quando si lavora in Informatica?`;
                        question.correct = result;
                    }
                    break;

                // Q11: Calcolo Avanzato (Complemento a 2 o Floating Point)
                case 11:
                    if (examType === 'D') {
                        // Advanced: Floating Point (Calcolo)
                        num1 = parseFloat(randInt(10, 50) + Math.random().toFixed(2));
                        const fp = calculateFloatingPoint(num1);
                        question.type = 'Floating Point (Mantissa + Esponente)';
                        question.text = `**PARTE PRATICA:** Dato il numero Decimale **${num1.toFixed(3)}**, normalizzalo per ottenere il formato in Notazione Scientifica Binaria (1.XXXXX * 2^E). Fornisci l'**Esponente (E)** e i primi **10 bit** della **Mantissa**.
                            **PARTE TEORICA:** Descrivi lo scopo dell'**Esponente Biased** (offset) nell'implementazione dello standard Floating Point (IEEE 754).`;
                        question.correct = `E: ${fp.E}; Mantissa: ${fp.mantissa}`;
                    } else {
                         // Standard: Complemento a Due (Teoria)
                        num1 = randInt(-100, -1);
                        result = toTwosComplement(num1);
                        question.type = 'Complemento a Due (Calcolo Semplice)';
                        question.text = `**PARTE PRATICA:** Calcola la rappresentazione in **Complemento a Due** su **8 bit** per il numero Decimale **${num1}**.
                            **PARTE TEORICA:** Spiega perch√© il Complemento a Due √® essenziale per l'aritmetica dei numeri negativi nei sistemi digitali.`;
                        question.correct = result;
                    }
                    break;
            }
            return question;
        }

        function generateExam(examType) {
            const examData = {
                id: generateUniqueID(),
                type: examType,
                date: document.getElementById('data-verifica').value,
                student: `${document.getElementById('nome-studente').value.trim()} ${document.getElementById('cognome-studente').value.trim()}`,
                class: document.getElementById('classe-studente').value.trim(),
                teacherId: window.teacherId,
                questions: []
            };

            for (let i = 1; i <= window.MAX_POINTS; i++) {
                examData.questions.push(generateMixedQuestion(i, examType));
            }
            return examData;
        }

        // -------------------------------------------------------------------------
        // GESTIONE FIREBASE E PDF
        // -------------------------------------------------------------------------

        async function handleGeneration(type, isStudent) {
            const nome = document.getElementById('nome-studente').value.trim();
            const cognome = document.getElementById('cognome-studente').value.trim();
            const classe = document.getElementById('classe-studente').value.trim();
            const data = document.getElementById('data-verifica').value;

            if (!nome || !cognome || !classe || !data) {
                console.error("Dati incompleti");
                return; // Non uso alert()
            }

            window.showLoading();
            try {
                const examData = generateExam(type);
                
                // Salva i dati della verifica (traccia + soluzioni)
                const docRef = window.doc(window.getExamCollectionRef(), examData.id);
                await window.setDoc(docRef, examData);

                await window.updateLinkContainers(); // Aggiorna la lista dei link salvati
                
                // Genera il PDF
                generatePDF(examData, isStudent);

            } catch (error) {
                console.error("Errore nel salvataggio della verifica:", error);
                document.getElementById('loading-overlay').innerHTML = `<p class="text-red-400 text-xl font-bold">Errore nel salvataggio: Controlla la console.</p>`;
            } finally {
                window.hideLoading();
            }
        }
        
        // Aggiorna il contenitore dei link di correzione
        window.updateLinkContainers = async () => {
            if (!window.db || !window.teacherId) return;

            const examTypes = ['A', 'B', 'C', 'D'];
            const q = window.query(window.getExamCollectionRef(), 
                                   window.where("teacherId", "==", window.teacherId)
                                  );

            let snapshot;
            try {
                snapshot = await window.getDocs(q);
            } catch (error) {
                console.error("Errore nel recupero dei link:", error);
                return;
            }
            
            const examsByType = { A: [], B: [], C: [], D: [] };
            snapshot.forEach(doc => {
                const data = doc.data();
                if (examTypes.includes(data.type)) {
                    examsByType[data.type].push(data);
                }
            });

            examTypes.forEach(type => {
                const container = document.getElementById(`link-container-${type}`);
                const message = document.getElementById(`link-message-${type}`);
                
                if (examsByType[type].length > 0) {
                    message.classList.add('hidden');
                    let html = '<ul class="space-y-2 text-sm">';
                    examsByType[type].sort((a, b) => new Date(b.date) - new Date(a.date)); // Ordina per data decrescente

                    examsByType[type].forEach(exam => {
                        const correctionLink = `${window.location.origin}${window.location.pathname}?examId=${exam.id}`;
                        const examName = exam.student && exam.student.trim() !== '' ? exam.student : `Verifica ${exam.id.substring(0, 5)}`;
                        
                        html += `
                            <li class="bg-white p-3 rounded-lg border border-gray-200 flex flex-col md:flex-row justify-between items-start md:items-center">
                                <span class="font-bold text-gray-800 flex-1 min-w-0 pr-4">
                                    ${exam.date ? `<span class="text-indigo-500">${exam.date}</span> - ` : ''} ${examName} (${exam.class})
                                </span>
                                <a href="${correctionLink}" target="_blank" class="text-blue-600 hover:text-blue-800 underline text-xs code-font mt-1 md:mt-0 whitespace-nowrap">
                                    Apri Link Correzione
                                </a>
                            </li>
                        `;
                    });
                    html += '</ul>';
                    
                    if (container) {
                        // Rimuove la lista precedente se esiste
                        let oldList = container.querySelector('ul');
                        if (oldList) oldList.remove();
                        
                        container.insertAdjacentHTML('beforeend', html);
                    }
                } else {
                    message.classList.remove('hidden');
                    message.textContent = `Nessuna verifica di Tipo ${type} generata.`;
                }
            });
        };

        // Generazione del PDF/Stampa
        function generatePDF(examData, forStudent) {
            const printArea = document.getElementById('print-area');
            let questionsHtml = '';
            
            examData.questions.forEach((q, index) => {
                const solutionHtml = forStudent ? '' : `
                    <div class="solution-box">
                        <span class="font-bold">Soluzione ${index + 1}:</span> ${formatSolution(q.correct)}
                    </div>
                `;
                
                const answerLines = forStudent ? '<span class="answer-line"></span><span class="answer-line"></span>' : '';

                questionsHtml += `
                    <div class="question-item">
                        <p class="question-text">${q.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>
                        ${solutionHtml}
                        ${answerLines}
                    </div>
                `;
            });

            const examTitle = `Verifica ${examData.type}: Informatica`;
            const headerHtml = `
                <div class="print-header">
                    <h1 class="text-3xl">${examTitle}</h1>
                    <p class="mt-1">
                        **Studente:** ${examData.student} | **Classe:** ${examData.class} | **Data:** ${examData.date}
                        <br>
                        **Punti Totali:** ${window.MAX_POINTS} | **Argomenti:** Sistemi di Numerazione, Operazioni Binaria, Subnetting e Teoria Complessa.
                    </p>
                </div>
            `;
            
            printArea.innerHTML = headerHtml + questionsHtml + '<p class="print-footer">-- Fine della Verifica --</p>';
            
            // Triggera la stampa del browser
            printArea.classList.remove('hidden');
            window.print();
            printArea.classList.add('hidden'); // Nasconde di nuovo l'area di stampa
        }

        // -------------------------------------------------------------------------
        // LOGICA VISTA DI CORREZIONE
        // -------------------------------------------------------------------------
        
        window.loadCorrectionView = async (examId) => {
            window.showLoading();
            
            try {
                const docRef = window.doc(window.getExamCollectionRef(), examId);
                const docSnap = await window.getDoc(docRef);

                if (!docSnap.exists()) {
                    console.error("Verifica non trovata!");
                    window.location.href = window.location.origin + window.location.pathname; // Torna alla home
                    return;
                }

                currentExamData = docSnap.data();
                
                // Popola l'intestazione
                document.getElementById('corr-student-name').textContent = currentExamData.student;
                document.getElementById('corr-class').textContent = currentExamData.class;
                document.getElementById('corr-title').textContent = `Tipo ${currentExamData.type} del ${currentExamData.date}`;
                
                // Popola il form di correzione
                const formContainer = document.getElementById('correction-form');
                formContainer.innerHTML = '';
                
                currentExamData.questions.forEach((q, index) => {
                    const questionNumber = index + 1;
                    const qId = `q${questionNumber}`;
                    
                    const isCorrect = currentExamData.results && currentExamData.results[qId] && currentExamData.results[qId].isCorrect;
                    const comment = currentExamData.results && currentExamData.results[qId] ? currentExamData.results[qId].comment || '' : '';
                    
                    const itemHtml = `
                        <div class="p-4 rounded-xl border-2 ${isCorrect ? 'border-green-500 bg-green-50' : 'border-gray-300 bg-gray-50'} shadow-md">
                            <h4 class="text-xl font-bold text-gray-800 mb-2 flex justify-between items-center">
                                Domanda ${questionNumber}
                                <span class="text-sm font-normal text-gray-500">${q.type}</span>
                            </h4>
                            <p class="text-lg font-semibold text-indigo-700 mb-3 leading-snug">${q.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>
                            
                            <div class="code-block mb-3">
                                <span class="font-bold text-green-300">Soluzione Esatta:</span>
                                <pre class="whitespace-pre-wrap code-font text-sm mt-1">${q.correct}</pre>
                            </div>

                            <div class="flex items-center space-x-4 mb-4">
                                <label class="flex items-center text-base font-semibold text-gray-700">
                                    <input type="checkbox" id="${qId}-correct" data-qid="${qId}" onchange="updateCorrectionPoints()" class="w-5 h-5 text-green-600 border-gray-300 rounded focus:ring-green-500" ${isCorrect ? 'checked' : ''}>
                                    <span class="ml-2">Corretta (1 Punto)</span>
                                </label>
                            </div>
                            
                            <label for="${qId}-comment" class="block text-sm font-medium text-gray-700">Commento Docente:</label>
                            <textarea id="${qId}-comment" data-qid="${qId}" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2">${comment}</textarea>
                        </div>
                    `;
                    formContainer.insertAdjacentHTML('beforeend', itemHtml);
                });

                // Carica il voto orale salvato, se esiste
                const savedOralGrade = currentExamData.oralGrade || 6.0;
                document.getElementById('voto-orale').value = savedOralGrade;

                updateCorrectionPoints(false); // Calcola i punti iniziali
                updateFinalGrade(); // Calcola il voto finale
                
                window.showCorrectionView();

            } catch (error) {
                console.error("Errore nel caricamento della vista di correzione:", error);
                window.location.href = window.location.origin + window.location.pathname;
            }
        };

        window.updateCorrectionPoints = (updateGrade = true) => {
            let points = 0;
            const checkboxes = document.querySelectorAll('#correction-form input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    points++;
                }
            });
            document.getElementById('corr-points').textContent = points;
            
            if (updateGrade) {
                updateFinalGrade();
            }
        };

        window.updateFinalGrade = () => {
            const points = parseInt(document.getElementById('corr-points').textContent, 10);
            const maxPoints = window.MAX_POINTS;
            const oralGrade = parseFloat(document.getElementById('voto-orale').value);

            if (isNaN(oralGrade) || oralGrade < 0 || oralGrade > 10) {
                document.getElementById('corr-grade-floored').textContent = 'ERR';
                document.getElementById('voto-scritto-base').textContent = 'N/A';
                return;
            }

            // Calcolo Voto Scritto in base 10
            const writtenGradeBase10 = (points / maxPoints) * 10;
            document.getElementById('voto-scritto-base').textContent = writtenGradeBase10.toFixed(2);

            // Calcolo Voto Finale (Scritto 70% + Orale 30%)
            const finalGrade = (writtenGradeBase10 * 0.7) + (oralGrade * 0.3);
            
            // Voto finale arrotondato per difetto
            const flooredGrade = Math.floor(finalGrade * 10) / 10;

            document.getElementById('corr-grade-floored').textContent = flooredGrade.toFixed(1);
        };
        
        window.saveAndDownloadResultsPDF = async () => {
            if (!currentExamData) return;

            window.showLoading();

            const results = {};
            let points = 0;
            
            // Raccogli i dati dalla correzione
            currentExamData.questions.forEach((q, index) => {
                const qId = `q${index + 1}`;
                const isCorrect = document.getElementById(`${qId}-correct`).checked;
                const comment = document.getElementById(`${qId}-comment`).value.trim();
                
                results[qId] = { isCorrect, comment, correct: q.correct };
                if (isCorrect) points++;
            });

            const oralGrade = parseFloat(document.getElementById('voto-orale').value);
            const writtenGradeBase10 = (points / window.MAX_POINTS) * 10;
            const finalGrade = (writtenGradeBase10 * 0.7) + (oralGrade * 0.3);
            const flooredGrade = Math.floor(finalGrade * 10) / 10;


            // Aggiorna Firestore
            const docRef = window.doc(window.getExamCollectionRef(), currentExamData.id);
            try {
                await window.setDoc(docRef, {
                    ...currentExamData,
                    results: results,
                    oralGrade: oralGrade,
                    finalGrade: flooredGrade,
                    points: points,
                    lastCorrected: new Date().toISOString()
                });
                console.log("Risultati salvati con successo in Firestore.");
            } catch (error) {
                console.error("Errore nel salvataggio dei risultati:", error);
                // Non uso alert, mostro l'errore nell'overlay
                document.getElementById('loading-overlay').innerHTML = `<p class="text-red-400 text-xl font-bold">Errore di salvataggio. Controlla la console.</p>`;
                window.hideLoading();
                return;
            }

            // Genera PDF/Stampa con riepilogo e commenti
            generateCorrectionPDF(points, writtenGradeBase10, oralGrade, flooredGrade, results);
            window.hideLoading();
        };

        function generateCorrectionPDF(points, writtenGradeBase10, oralGrade, finalGrade, results) {
            const printArea = document.getElementById('print-area');
            let questionsHtml = '';
            
            // 1. Riepilogo del Voto
            const summaryHeader = `
                <div class="print-header !border-green-500">
                    <h1 class="text-3xl text-green-700">Scheda di Correzione e Commenti</h1>
                    <p class="mt-1">
                        **Studente:** ${currentExamData.student} | **Classe:** ${currentExamData.class} | **Data Verifica:** ${currentExamData.date}
                    </p>
                </div>
                <div class="mb-6 p-4 border border-yellow-400 bg-yellow-50 rounded-lg text-sm">
                    <p class="font-bold text-lg text-yellow-800 mb-2">RIEPILOGO VALUTAZIONE</p>
                    <p>Punti Scritto: <strong class="text-blue-600">${points} / ${window.MAX_POINTS}</strong></p>
                    <p>Voto Scritto (Base 10): <strong class="text-blue-600">${writtenGradeBase10.toFixed(2)}</strong> (Peso 70%)</p>
                    <p>Voto Orale: <strong class="text-purple-600">${oralGrade.toFixed(1)}</strong> (Peso 30%)</p>
                    <p class="text-2xl font-black mt-2 text-red-700">VOTO FINALE: ${finalGrade.toFixed(1)} / 10</p>
                </div>
            `;
            
            // 2. Dettagli Domanda per Domanda
            currentExamData.questions.forEach((q, index) => {
                const qId = `q${index + 1}`;
                const result = results[qId];
                const statusColor = result.isCorrect ? 'text-green-600' : 'text-red-600';
                const statusText = result.isCorrect ? 'CORRETTA' : 'ERRATA';
                
                const commentHtml = result.comment 
                    ? `<p class="mt-2 text-sm italic border-t border-gray-200 pt-2">**Commento Docente:** ${result.comment}</p>` 
                    : '';

                questionsHtml += `
                    <div class="question-item !border-gray-400">
                        <p class="question-text">${q.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>
                        <div class="mt-2 p-2 rounded border ${result.isCorrect ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50'}">
                            <p class="font-bold ${statusColor}">STATO: ${statusText} (Punti: ${result.isCorrect ? '1' : '0'})</p>
                            <p class="text-xs font-semibold text-gray-700 mt-1">Soluzione Attesa:</p>
                            <pre class="code-font text-xs whitespace-pre-wrap">${q.correct}</pre>
                            ${commentHtml}
                        </div>
                    </div>
                `;
            });

            printArea.innerHTML = summaryHeader + questionsHtml + '<p class="print-footer">-- Fine Scheda di Correzione --</p>';
            
            // Triggera la stampa del browser
            printArea.classList.remove('hidden');
            window.print();
            printArea.classList.add('hidden'); // Nasconde di nuovo l'area di stampa
        }

    </script>
</body>
</html>
